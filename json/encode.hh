// Copyright (c) 2022 Mikael Simonsson <https://mikaelsimonsson.com>.
// SPDX-License-Identifier: BSL-1.0

// # Encode string

#pragma once

#include "snn-core/exception.hh"
#include "snn-core/strcore.hh"
#include "snn-core/chr/common.hh"
#include "snn-core/chr/fn/lookup.hh"
#include "snn-core/json/error.hh"
#include "snn-core/range/contiguous.hh"
#include "snn-core/unicode/core.hh"
#include "snn-core/utf8/core.hh"
#include "snn-core/utf8/encode.hh"

namespace snn::json
{
    // ## Enums

    // ### option

    enum class option : u16
    {
        // Encode according to the JSON specification with the addition of:
        // U+2028 LINE SEPARATOR is encoded as "\u2028".
        // U+2029 PARAGRAPH SEPARATOR is encoded as "\u2029".
        // This is to support ECMAScript 2018 and older:
        // https://en.wikipedia.org/wiki/JSON#Character_encoding
        none = 0,

        // Escape additional characters.
        escape_ampersand    = 0b0000'0001,         // '&' is encoded as "\u0026".
        escape_amp          = escape_ampersand,    // Alias
        escape_greater_than = 0b0000'0010,         // '>' is encoded as "\u003e".
        escape_gt           = escape_greater_than, // Alias
        escape_less_than    = 0b0000'0100,         // '<' is encoded as "\u003c".
        escape_lt           = escape_less_than,    // Alias
    };

    // ## Functions

    // ### Bitwise operators

    [[nodiscard]] constexpr option operator&(const option left, const option right) noexcept
    {
        return static_cast<option>(to_underlying(left) & to_underlying(right));
    }

    [[nodiscard]] constexpr option operator|(const option left, const option right) noexcept
    {
        return static_cast<option>(to_underlying(left) | to_underlying(right));
    }

    // ### encode

    namespace detail
    {
        // Lookup tables generated by: detail/encode.gen.cc

        inline constexpr array<bool, 256> encode_passthrough_lookup{
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        };

        inline constexpr array<bool, 256> encode_passthrough_opt_lookup{
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        };

        template <typename Buf>
        constexpr void encode(const cstrview s, const option options, strcore<Buf>& append_to)
        {
            append_to.reserve_append(s.size() + 2); // Reserve minimal size.

            append_to.append('"');

            auto is_passthrough = snn::chr::fn::lookup{detail::encode_passthrough_lookup};
            if (options != option::none)
            {
                is_passthrough = snn::chr::fn::lookup{detail::encode_passthrough_opt_lookup};
            }

            auto rng = s.range();
            while (rng)
            {
                const auto passthrough_rng = rng.pop_front_while(is_passthrough);
                if (passthrough_rng)
                {
                    append_to.append(cstrview{passthrough_rng});
                }

                if (rng)
                {
                    const char c = rng.front(assume::not_empty);
                    if (snn::chr::is_ascii(c))
                    {
                        rng.drop_front(assume::not_empty);
                        switch (c)
                        {
                            case '\b':
                                append_to.append(R"(\b)");
                                break;

                            case '\t':
                                append_to.append(R"(\t)");
                                break;

                            case '\n':
                                append_to.append(R"(\n)");
                                break;

                            case '\f':
                                append_to.append(R"(\f)");
                                break;

                            case '\r':
                                append_to.append(R"(\r)");
                                break;

                            case '"':
                                append_to.append(R"(\")");
                                break;

                            case '&':
                                if ((options & option::escape_amp) == option::escape_amp)
                                {
                                    append_to.append(R"(\u0026)");
                                }
                                else
                                {
                                    append_to.append('&');
                                }
                                break;

                            case '<':
                                if ((options & option::escape_lt) == option::escape_lt)
                                {
                                    append_to.append(R"(\u003c)");
                                }
                                else
                                {
                                    append_to.append('<');
                                }
                                break;

                            case '>':
                                if ((options & option::escape_gt) == option::escape_gt)
                                {
                                    append_to.append(R"(\u003e)");
                                }
                                else
                                {
                                    append_to.append('>');
                                }
                                break;

                            case '\\':
                                append_to.append(R"(\\)");
                                break;

                            default:
                                constexpr usize pad_to_four = 4;
                                append_to.append(R"(\u)");
                                append_to.template append_integral<math::base::hex>(to_byte(c),
                                                                                    pad_to_four);
                                break;
                        }
                    }
                    else
                    {
                        const u32 cp = rng.pop_front_codepoint().value;
                        if (cp != utf8::invalid)
                        {
                            if (unicode::is_plane_0(cp))
                            {
                                if (cp == 0x2028)
                                {
                                    append_to.append(R"(\u2028)");
                                }
                                else if (cp == 0x2029)
                                {
                                    append_to.append(R"(\u2029)");
                                }
                                else
                                {
                                    utf8::encode(cp, append_to, promise::is_valid);
                                }
                            }
                            else
                            {
                                const u32 l = unicode::encode_leading_surrogate(cp);
                                const u32 t = unicode::encode_trailing_surrogate(cp);

                                constexpr usize pad_to_four = 4;
                                append_to.append(R"(\u)");
                                append_to.template append_integral<math::base::hex>(l, pad_to_four);
                                append_to.append(R"(\u)");
                                append_to.template append_integral<math::base::hex>(t, pad_to_four);
                            }
                        }
                        else
                        {
                            throw_or_abort(error::invalid_utf8);
                        }
                    }
                }
            }

            append_to.append('"');
        }
    }

    template <any_strcore Str = str>
    [[nodiscard]] constexpr Str encode(const transient<cstrview> s,
                                       const option options = option::none)
    {
        Str append_to;
        detail::encode(s.get(), options, append_to);
        return append_to;
    }

    template <typename Buf>
    constexpr void encode(const transient<cstrview> s, const option options,
                          strcore<Buf>& append_to, assume::no_overlap_t)
    {
        snn_should(std::is_constant_evaluated() || !s.get().overlaps(append_to));
        detail::encode(s.get(), options, append_to);
    }
}
