# Ranges and range views (including `[c]strrng` aliases)

A range is typically a lightweight object that refers to a sequence of elements (iterator pair) or
produces a set of values (generating). Technically any object can be a range as long as it has the
required member functions (see requirements below).

The "string ranges" are specialized for extended functionality:
 * `range::contiguous<char*>` (alias: `strrng`)
 * `range::contiguous<const char*>` (alias: `cstrrng`)

For range algorithms see [snn-core/algo/](../algo/).


## Overview

| Path                                   | Description                                                |                                        |
| -------------------------------------- | ---------------------------------------------------------- | -------------------------------------- |
| [iter/](iter)                          | Iterators                                                  | [Readme](iter/#readme)                 |
| [unchecked/](unchecked)                | Unchecked (unsafe) ranges                                  | [Readme](unchecked/#readme)            |
| [view/](view)                          | Range views                                                | [Readme](view/#readme)                 |
| [bidirectional.hh](bidirectional.hh)   | Bidirectional range                                        | [Example/Tests](bidirectional.test.cc) |
| [contiguous.fwd.hh](contiguous.fwd.hh) | Contiguous range (forward declare) and `[c]strrng` aliases |                                        |
| [contiguous.hh](contiguous.hh)         | Contiguous range                                           | [Example/Tests](contiguous.test.cc)    |
| [forward.hh](forward.hh)               | Forward range                                              | [Example/Tests](forward.test.cc)       |
| [generate.hh](generate.hh)             | Infinite range of values generated by function             | [Example/Tests](generate.test.cc)      |
| [integral.hh](integral.hh)             | Range of all values for an integral type                   | [Example/Tests](integral.test.cc)      |
| [random\_access.hh](random_access.hh)  | Random access range                                        | [Example/Tests](random_access.test.cc) |
| [step.hh](step.hh)                     | Step range                                                 | [Example/Tests](step.test.cc)          |
| [step\_back.hh](step_back.hh)          | Step-back range                                            | [Example/Tests](step_back.test.cc)     |


## Types

### Input

Input ranges are non-copyable and single-pass.

Input ranges are owning and iterators are invalidated when the range is destroyed.

Example: A range reading lines from a file descriptor.

### Forward

Forward ranges are input ranges that are copyable and multi-pass.

Forward ranges are non-owning and iterators must be valid even if the range is destroyed.

Conceptually a forward range is a pair of iterators.

Example: A range for a singly linked list.

### Bidirectional

Bidirectional ranges are forward ranges that can also be traversed in reverse.

Example: A range for a doubly linked list.

### Random access

Random access ranges are bidirectional ranges where each element in the range can be accessed in
constant time.

### Contiguous

Contiguous ranges are random access ranges where elements are located contiguously in memory.


## Requirements

Ranges must have the following member functions:

 * Input
   * `explicit operator bool() const`
   * `bool is_empty() const`
   * `... begin()`
   * `... end()`
   * `... front(promise::not_empty_type)`
   * `void drop_front(promise::not_empty_type)`
 * Bidirectional
   * `... back(promise::not_empty_type)`
   * `void drop_back(promise::not_empty_type)`
 * Random access
   * `... at(usize, promise::within_bounds_type)`
   * `usize count() const`
 * Contiguous
   * `... pop_back(promise::not_empty_type)`
   * `... pop_back_n(usize)`
   * `... pop_front(promise::not_empty_type)`
   * `... pop_front_n(usize)`

The following member functions are recommended but not required:

 * Input
   * `... front(promise::not_empty_type) const`
   * `optional<...> front()`
   * `optional<...> front() const`
 * Forward
   * `... begin() const`
   * `... end() const`
   * `... cbegin() const`
   * `... cend() const`
 * Bidirectional
   * `... back(promise::not_empty_type) const`
   * `optional<...> back()`
   * `optional<...> back() const`
 * Random access
   * `... at(usize, promise::within_bounds_type) const`
   * `optional<...> at(usize)`
   * `optional<...> at(usize) const`
 * Contiguous
   * `optional<...> pop_back()`
   * `optional<...> pop_front()`
